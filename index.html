<!DOCTYPE html>
<html lang="en">
<head>
    <title>CPSC 487/587</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@1.5.1/quaternion.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine, get_default_lil_gui, refresh_displays} from "./js/utils/utils_three.js";
    import {B1Z1Robot, XArm7Robot} from "./js/utils/utils_robot.js";
    import {mul_matrix_matrix, mul_matrix_scalar, add_matrix_matrix} from "./js/utils/utils_math.js";
    import {optimization_solve} from "./js/utils/utils_optimization.js";

    // let engine = ThreeEngine.new_default_3d(0.7, 0, 0.5, false);
    let engine = ThreeEngine.new_default_3d(1, 0, 0.5, false);

    let robot = new XArm7Robot();
    robot.spawn_robot(engine);

    let links = robot.links;
    let joints = robot.joints;
    let kinematic_hierarchy = robot.kinematic_hierarchy;
    let current_joint_angles = Array(joints.length).fill(0);

    let actions = {
        reset: function() {
            current_joint_angles.fill(0);
            refresh_displays(gui);
        }
    }

    let gui = get_default_lil_gui();
    gui.add(actions, 'reset').name('Reset')

    const x = [ [0.07], [0], [0] ];
    const y = [ [0], [0.07], [0] ];
    const z = [ [0], [0], [0.07] ];

    const exponentiate_so3 = (m) => {
        let epsilon = 1e-10;
        let beta = Math.sqrt(m[0][0] * m[0][0] + m[1][0] * m[1][0] + m[2][0] * m[2][0]);
        let p = beta > epsilon ? Math.sin(beta) / beta : Math.pow(beta, 2) / 6 + Math.pow(beta, 4) / 120;
        let q = beta > epsilon ? (1 - Math.cos(beta)) / (beta * beta) : 0.5 - Math.pow(beta, 2) / 24 + Math.pow(beta, 4) / 720;
        
        let m1 = numeric.identity(3);
        let m2 = mul_matrix_scalar(m, p);
        let m3 = mul_matrix_scalar(mul_matrix_matrix(m, m), q);
        let m_e = add_matrix_matrix(add_matrix_matrix(m1, m2), m3);
        return m_e;
    }

    const get_next_transformation = (joint, angle, prev_transformation) => {
        const T_i = prev_transformation;
        const T_c = joint.xyz_rpy_SE3_matrix;
        let T_j = numeric.identity(4);
        if (joint.joint_type_string === 'revolute') {
            let axis = joint.axis;
            let a = axis[0][0];
            let b = axis[1][0];
            let c = axis[2][0];
            let m = [[0, -c, b], [c, 0, -a], [-b, a, 0]];
            m = mul_matrix_scalar(m, angle);
            let m_e = exponentiate_so3(m);
            T_j = [[m_e[0][0], m_e[0][1], m_e[0][2], 0],
                   [m_e[1][0], m_e[1][1], m_e[1][2], 0],
                   [m_e[2][0], m_e[2][1], m_e[2][2], 0],
                   [0, 0, 0, 1]];
        } else if (joint.joint_type_string === 'prismatic') {
            let axis = joint.axis;
            let translation = numeric.mul(axis, angle);
            T_j[0][3] = translation[0][0];
            T_j[1][3] = translation[1][0];
            T_j[2][3] = translation[2][0];
        }
        // if fixed, T_j remains as the identity matrix
        let T = mul_matrix_matrix(mul_matrix_matrix(T_i, T_c), T_j);
        return T
    }

    const calculate_forward_kinematics = (joint_angles) => {
        let fk = [];
        let transformation = numeric.identity(4);
        let joint_count = 0;
        links.forEach(element => {
            if (joint_count >= joints.length) {
                return;
            }

            if (element.children_joint_idxs.length != 0) {
                // get joint
                let joint_idx = element.children_joint_idxs[0]
                let joint = joints[joint_idx];

                // get angle name
                if (joint.joint_type_string !== 'fixed') {           
                    let angle = joint_angles[joint_count];
                    transformation = get_next_transformation(joint, angle, transformation);
                }
            }

            fk.push(transformation)
            joint_count++;
            robot.set_link_mesh_pose_from_SE3_matrix(engine, element.link_idx + 1, transformation);
        });
        return fk
    }

    const generate_objective_function = (target_position) => {

        const objective_function = (joint_angles) => {
            // if (joint_angles[1] > 0.7) {
            //     return 1000;
            // }
            let fk = calculate_forward_kinematics(joint_angles);
            let end_effector = fk[fk.length - 1];
            let end_effector_position = [end_effector[0][3], end_effector[1][3], end_effector[2][3]];
            
            let error = numeric.sub(end_effector_position, target_position);
            let error_norm = numeric.norm2(error);
            // console.log(end_effector_position, target_position, joint_angles, fk[18])
            // engine.draw_debug_vector([0,0,0], end_effector_position, 0.003, 0.03, 0xff2222);
            // console.log(error_norm)
            return error_norm;
        }

        return objective_function
    }

    let objective_function = generate_objective_function([0.7, 0.02, -0.1])

    console.log(objective_function(current_joint_angles))
    current_joint_angles[5] = 0.00001
    console.log(objective_function(current_joint_angles))
    current_joint_angles[5] = 2
    console.log(objective_function(current_joint_angles))

    let res = optimization_solve(objective_function, Array(joints.length).fill(0), undefined, 'bfgs')
    current_joint_angles = res
    console.log(res)

    engine.animation_loop( ()  => {
        const a = calculate_forward_kinematics(current_joint_angles)
    });

</script>
</body>
</html>